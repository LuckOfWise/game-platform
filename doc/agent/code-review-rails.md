# Rails コードレビューガイドライン for AIエージェント

## I. コードの基本的な品質と可読性

### 命名規則の遵守と意味の明確化
- 中間テーブルのモデル名は、**関係性の意味を表す命名**（例: `UserMagazine` ではなく `Subscription`）を使用する。
- メソッド名や変数名は、`check_xxx` のような抽象的な命名は避け、何を確認し、その結果どうなるのかが分かるようにする（例: `check_image` ではなく `image_must_be_allowed_content_type`）。
- Ruby/Railsの慣習（クラスは名詞、メソッドは副作用があれば動詞、なければ名詞、真偽値を返すメソッドには疑問符、例外を投げるメソッドには感嘆符）に従った命名にする。

### コードのシンプルさと単一責任
- メソッドやクラスは**一つの役割だけを担う**ようにする。複雑な役割は小さな単位に分割して委譲する。
- **YAGNI（You Ain't Gonna Need It）の原則**に従い、現時点で必要ではない機能やコードを書かない。

### コメントの適切な使用
- コメントはコードの動作を説明するのではなく、**コードだけでは表現しきれない背景、設計上のトレードオフ**などを記述する。
- `NOTE`, `TODO`, `FIXME`などの**アノテーション**を活用する。

---

## II. データ管理とデータベース操作の効率化・安全性

### データベースでの処理の優先
- 特定の列の値を取得するだけならば、`map`よりも`pluck`を使用する。
- データの集計処理は、Ruby側ではなく**データベース側で集計**（例: `group`, `count`）を行う。

### 関連データの効率的な取得
- `has_many`関連では、`eager_load`よりも`preload`を使用する。
- `preload`したアソシエーションを利用する際に、ビュー側で追加のクエリが発生しないよう、`scope`付きリレーションを用意するか、データをハッシュとして事前に準備する。
- `preload`されたデータに対して`exists?`や`count`を呼ぶとN+1問題を引き起こすため、それぞれ`present?`や`size`に置き換える。

### データ整合性と安全性の確保
- 必須カラムには`NOT NULL`制約を、一意であるべきデータには**ユニークインデックス**をデータベースレベルで設定する。
- 複数のレコード更新処理は**トランザクションで囲む**。失敗時に例外をスローする`create!`や`update!`を使用する。
- オブジェクトの取得は**ログインユーザーを起点に行う**。
- `seed`やスクリプトでのデータ登録には、`create`ではなく`create!`を使用する。
- 大量データを扱うループ処理では、`each`の代わりに`find_each`を使用する。

---

## III. ビューとコントローラーの分離と最適化

### ビューのシンプル化
- ビューには複雑なロジックを書かず、**ActionViewヘルパー、Model、Decorator等、適切な場所へロジックを移動させる。
- パーシャルのルート要素は**一つに限定**する。
- パーシャルのルート要素にマージンを持たせず、**親コンポーネント側でマージンを設定する**。
- 時間や日付のフォーマットには`I18n.l`を使用する。

### コントローラーの責務の明確化
- コントローラーにはモデルの知識を持たせず、**リクエストの処理とレスポンスの準備に限定**し、データ操作の詳細なロジックはモデルに委譲する。
- 名前空間が区切られている場合、その配下の共通処理を定義するための**基底コントローラー**（例: `Admins::ApplicationController`）を用意し、各コントローラーはそれを継承する。
- ユーザーの種類に応じて**コントローラーの`namespace`を分ける**。

### ルーティングの最適化
- ルーティングは`resources`メソッドを用いてRESTfulな定義をする。
- ルーティングをネストする際は、`module`オプションを使用してコントローラーのファイル配置と名前空間を対応させる。
- マイページのような「ユーザーから見て単一となるリソース」には、`resources`ではなく**単数形の`resource`を使用し、`id`を含まないURLを生成する**。
- レコードの一覧を取得する際には、必ず`order`句を追加する。

### セッションの最小限利用
- セッションに保存する値は、`id`やキーのみに限定する。
- `destroy`メソッドの代わりに`destroy!`を使用する。

---

## IV. 堅牢なテストコードの作成

### テストの説明の具体性
- `describe`, `context`, `it`ブロックの記述は**具体的で明確**にする。「正常に処理される」や「○○が正しいこと」のような曖昧な表現は避ける。

### テストコードの構造化と独立性
- テストコードは「**準備（Arrange）、実行（Act）、検証（Assert）**」の三段階で構造化する。
- 期待値に使う値は、同じテストコード内でできるだけ近くで準備する。FactoryBotのデフォルト値に依存しすぎない。
- 入力値や期待値は、変数ではなく**ベタ書き**にする。

### 効率的で意味のあるテスト
- Railsやライブラリの標準機能のテストは書かない。
- システムテストは、ユーザー視点での基本的な動線や操作後の画面変化を確認するに留める。細かいロジックの確認はユニットテストで行う。
- デザインに依存しないテストを書くために、CSSクラスではなく`data-test-selector`のようなテスト専用の属性を使用する。
- `let`や`let!`の乱用を避け、`before`ブロックやローカル変数を活用する。
- 「～されないこと」の検証を行う際には、「～される条件」も併せて検証する。
- `sleep`の使用を避け、「サーバーからのレスポンスによって画面に表示される要素」で待つ（例: `expect(page).to have_content`）。
- FactoryBotでオブジェクトを作成する際、検証に利用しない属性は含めない。
- Strong Parameterの設定漏れを検知するため、`action_on_unpermitted_parameters`を`:raise`に設定する。

---

## V. 開発環境とプロジェクト管理

### 環境間の差異の意識
- 開発環境と本番環境で**システム構成（例: データベースの種類やバージョン）を極力揃える**。
- 環境に依存する値は、コード中で`Rails.env`などで分岐させるのではなく、**環境変数や`credentials.yml.enc`を利用して外部化する**。

### Gemバージョンの管理
- Gemのバージョンを安易に固定しない。
- テストを十分に書いた上で、定期的に`bundle update`を実行する。
- やむを得ずバージョンを固定する場合には、その理由と関連する情報（例: GitHub Issueへのリンク）をコメントとして残す。

### 禁止リストより許可リスト
- `skip_before_action`などでアクションを制限する際に、`except`のような禁止リスト方式ではなく、`only`のような許可リスト方式を優先的に使用する。

---

これらのガイドラインは、AIエージェントがコードレビューにおいて、単なる構文チェックに留まらず、コードの意図、品質、保守性、安全性、効率性といった多角的な観点から深い洞察を提供し、より洗練されたRuby on Railsアプリケーションの開発に貢献するための基盤となる。
